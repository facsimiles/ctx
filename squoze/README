Squoze - reversible unicode string hashes.

embedding text in integers

Squoze is a type of unicode string hashes designed for use in content addressed
storage. The hashes trade the least significant bit of digest data for being
able to embed digest_size-1 bits of payload data in the hash.

An important use of content addressed storage is interned strings. This
embedding of words/tokens that fit in registers directly can speed up many
tasks involving text processing like parsing and even runtime dispatch in many
programming languages. On 64bit systems there is enough room in registers to
fit 8charater long tokens directly with minimal processing overhead.

squoze-bignum
    UTF5+ encoding, supporting arbitrary length unicode strings stored in
    bignums.
squoze32
    UTF5+ embed encoding, supporting up to 6 lower-case ascii of embedded data
squoze52
    UTF5+ embed encoding, supporting up to 10 lower-case ascii of embedded
    data, 52bit integers can be stored without loss in a double.
squoze62
    UTF5+ embed encoding, supporting up to 12 unicode code points.
squoze64
    UTF-8 embed encoding, supporting up to 8 ASCII chars of embedded data.
squoze256
    UTF5+ embed encoding, supporting up to 50 unicode code points

squoze is still under development, preliminary variants for python3 and C are
available, the C code is the hashes tested in the benchmarks.

squoze64 implementation

the squoze-64 encoding is a small bitmanipulation of UTF-8 in-memory encoding,
for strings that will fit only the first byte is manipulated and only if it
ascii and not @ the value is double and 1 is added. When the first byte does
not match our constraints we store 129 - which means the following 7bytes
directly encode the value

uint64_t squoze64(const char *utf8, size_t len)
{
  size_t   squoze_dim = 64;
  uint64_t hash       = 0;
  uint8_t *encoded    = (uint8_t*)&hash;
  uint8_t  first_byte = ((uint8_t*)utf8)[0];

  if (first_byte<128
      && first_byte != '@'
      && (len <= (squoze_dim/8)))
  {
    for (int i = 0; utf8[i]; i++)
      encoded[i] = utf8[i];
    encoded[0] = encoded[0]*2+1;
    return *((uint64_t*)&encoded[0]);
  }
  else if (len <= (squoze_dim/8)-1)
  {
    for (int i = 0; utf8[i]; i++)
      encoded[i+1] = utf8[i];
    encoded[0] = 129;
    return *((uint64_t*)&encoded[0]);
  }

  // murmurhash one-at-a-time
  hash = 3323198485ul;
  for (unsigned int i = 0; i < len; i++)
  {
    uint8_t key = utf8[i];
    hash ^= key;
    hash *= 0x5bd1e995;
    hash ^= hash >> 15;
  }
  return hash & ~1; // make even
}

const char *squoze64_decode (uint64_t hash)
{
  static uint8_t buf[10];
  buf[8] = 0;
  ((uint64_t*)buf)[0]= hash; // or memcpy (buf, hash, 8);
  if ((buf[0] & 1) == 0)
     return NULL;
  if (buf[0] == 129)
     return buf+1;
  buf[0] /= 2;
  return buf;
}

UTF5+ and squoze-bignum implementation

The first stage of this encoding is encoding to UTF5+ which extends UTF-5. The
symbol 'G' with value 16 does not occur in normal UTF-5 and is used to change
encoding mode to a sliding window, valid UTF5 strings are correctly decoded by
a UTF5+ decoder.

In squeeze mode the initial offset is set based on the last encoded unicode
codepoint in UTF5 mode. Start offsets for a code point follow the pattern 19 +
26 * N, which makes a-z fit in one window. In sliding window mode the following
quintets have special meaning:

0  0  emit SPACE
1  1  codepoint at offset + 0
2  2  codepoint at offset + 1
   ..
10 A  codepoint at offset + 9
11 B  codepoint at offset + 10
12 C  codepoint at offset + 11
   ..
26 Q  codepoint at offset + 25
27 R  offset += 26 *1
28 S  offset += 26 *1
29 T  offset += 26 *1
30 U  offset += 26 *1
31 V  switch to UTF-5 mode

For compatibility with UTF-5 we start out in UTF-5 mode rather than window
mode.

The encoder decides if the current mode is kept or not for every codepoint. The
cost in output quintets is computed for UTF-5 and windowed is computed for both
this and the next codepoint. We switch from UTF-5 to windowed when the cost of
switching considering this and the next code points is equal or smaller, in the
other direction we only switch if there is a gain to be had.

For example the string Hello World is encoded as follows:

H   e  l l o   W  o  r l d                             11 bytes
GT2 U5 C C F 0 TH UF I C 4     16 quintets = 80 bits = 10 bytes

h  e l l o   w o r l d     11 bytes
G8 5 C C F 0 N F I C 4     12 quintets = 60 bits = 7.5bytes padded to 8 bytes

When transforming a quintet sequence into an integer the initial mode is
encoded as a bit of 1 if we are starting out in UTF-5 mode, allowing us to skip
the G. To create an integer we start with 0, add the integer value of the first
quintet. If there are more quintets, multiply by 32 and continue adding
quintets. The resulting value is multipled by 4, the second lowest bit set
according to windowed or utf-5 initial mode and the lowest bit set.

squoze32, squoze52 and squoze62 implementation

These hashes are just like squoze-bignum if they as UTF5+ encode as fewer than
6, 10 or 12 quintets. If this is not the case a murmurhash is computed and the
lowest bit stripped.

benchmarks

The implementation benchmarked is an open adressing hashtable storing heap
allocated chunks containing both the hash, length and raw byte data for the
UTF8 string.

The alwaysintern variants of squoze are using the squoze hashes without their
embedding capability.

The create column is the microseconds taken on average to intern a word, lookup
is the time taken the second and subsequent times a string is referenced. For
comparisons the handle/pointer of the interned string would normally be used
and be the same for all cases, decode is the time taken for getting a copy of
the interned string.

The embed% column shows how many of the words got embedded instead of interned.

The RAM use column shows the amount of bytes used by the allocations for
interned strings as well as the size taken by the hash table used, without the
size taken by tempty slots in the hash-table to be comparable with what a more
compact optimizing structure used when targeting memory constrained systems.

The hashes with the direct UTF8 embedding are the most reliable optimization
when only runtime/energy use is considered. The UTF5 embeddings save more RAM
and allow more guarantee collision free strings but are more expensive to
compute.

On embedded platforms not having the strings consume heap space can be a
significant saving, this should however be weighed against the overhead of
needing 32bit values to store/pass around sometimes being able to use 16bit
references to strings is a more significant overall saving.

5159 words, max-word-len: 4

                           create lookup decode embed% RAM use
  murmurhash OAAT 32bit    1.472  0.423  0.022  0%     171848
      squoze64-utf8        0.050  0.050  0.041  100%   48
      squoze32-utf8        0.060  0.059  0.047  100%   48
      squoze32-utf5        0.265  0.257  0.097  95%    9842
      squoze52-utf5        0.222  0.236  0.112  100%   48
      squoze62-utf5        0.224  0.244  0.112  100%   48
squoze32-utf5 alwaysintern 0.861  0.298  0.027  0%     171848
squoze52-utf5 alwaysintern 0.868  0.280  0.025  0%     213120
squoze62-utf5 alwaysintern 0.757  0.279  0.024  0%     213120

23924 words, max-word-len: 6

                           create lookup decode embed% RAM use
  murmurhash OAAT 32bit    0.516  0.148  0.014  0%     793018
      squoze64-utf8        0.066  0.065  0.032  100%   48
      squoze32-utf8        0.290  0.095  0.023  22%    686746
      squoze32-utf5        0.405  0.298  0.085  71%    224008
      squoze52-utf5        0.326  0.303  0.135  96%    35327
      squoze62-utf5        0.316  0.329  0.155  100%   141
squoze32-utf5 alwaysintern 0.951  0.459  0.017  0%     793018
squoze52-utf5 alwaysintern 1.422  0.565  0.014  0%     984410
squoze62-utf5 alwaysintern 1.516  0.691  0.015  0%     984410

55814 words, max-word-len: 8

                           create lookup decode embed% RAM use
  murmurhash OAAT 32bit    0.345  0.118  0.025  0%     1836955
      squoze64-utf8        0.078  0.066  0.040  100%   213
      squoze32-utf8        0.311  0.101  0.023  9%     1730683
      squoze32-utf5        0.367  0.200  0.058  30%    1464553
      squoze52-utf5        0.330  0.307  0.130  88%    291548
      squoze62-utf5        0.320  0.303  0.136  97%    80746
squoze32-utf5 alwaysintern 0.498  0.261  0.025  0%     1836955
squoze52-utf5 alwaysintern 1.582  0.702  0.023  0%     2283467
squoze62-utf5 alwaysintern 2.094  0.929  0.024  0%     2283467

82966 words, max-word-len: 10

                           create lookup decode embed% RAM use
  murmurhash OAAT 32bit    0.424  0.161  0.023  0%     3079310
      squoze64-utf8        0.162  0.083  0.035  67%    1197632
      squoze32-utf8        0.359  0.125  0.024  6%     2973038
      squoze32-utf5        0.388  0.202  0.047  20%    2706908
      squoze52-utf5        0.382  0.339  0.124  79%    848388
      squoze62-utf5        0.350  0.334  0.143  90%    338412
squoze32-utf5 alwaysintern 0.461  0.226  0.024  0%     3079310
squoze52-utf5 alwaysintern 1.365  0.556  0.027  0%     3743038
squoze62-utf5 alwaysintern 1.943  0.758  0.026  0%     3743038

97605 words, max-word-len: 12

                      create lookup decode embed% RAM use
murmurhash OAAT 32bit 0.407  0.164  0.022  0%     3494990
    squoze64-utf8     0.210  0.112  0.039  57%    1992568
    squoze32-utf8     0.451  0.201  0.040  5%     3388718
    squoze32-utf5     0.617  0.361  0.056  17%    3122588

