<html>
    <head><title>ctx - interactive vector protocol and platform</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type='text/css'>
      @import url(ctx.css);
    </style>
  </head>

  <body>
     <div id='menu'>
              <a href='https://ctx.graphics/'>ctx</a>
              <a href='https://ctx.graphics/.git/'>git</a>
              <a href='#downloads'>downloads</a>
              <br/>
              <a href='rasterizer/'>rasterizer</a>
              <a href='protocol/'>protocol</a>
              <a href='#future'>future</a>
              <a href='#license'>license</a>
              <br/>
              <a href='mcu/'>videos</a>
              <a href='tests/'>tests</a>
              <a href='glitch/'>glitch</a>
      </div>

      <div id='page'>
      <img style='max-width:100%' src='tests/png-640x240/ctx.png'/>

      <p>ctx is a platform for (interactive) 2d vector graphics, built
      around a serialization <a href='protocol/'>format/protocol</a> for HTML5s
      2D canvas which can work as an extension to ANSI/VT terminal handlers.
      </p>

      <!--
      <p>ctx is a configurable and <a href='mcu/'>lightweight</a> 2D vector
      graphics stack with focus on remote and deferred rendering building on
      top of the HTML5 canvas 2D context
      specification. The project provides as single header library
      which implements both a binary and textual <a
      href='protocol/'>drawlist protocol</a>. The ctx single-header
      library provides APIs for registering keybindings and pointer events
      with callbacks in user-relative coordinates. Events and rendering are
      abstracted for linux framebuffer, SDL2, braille in terminal and running
      in the ctx terminal. The ctx terminal is the binary built in the
      toplevel of a <a href='/.git/'>ctx git</a> checkout. This terminal
      serves as a demanding example for app-development with ctx, it used to
      be faster - but peformance of minimal framebuffer touching has been
      replaced with well-formed vector output - for /dev/fb0 usage fbterm is
      a *lot* faster - but lacks the richer media of ctx, which permits the terminal to
      run inside itself with minimal overhead. From within the terminal even
      <a href='https://ctx.graphics/file/clients/clock.sh.html'>shell
      scripts</a> get the ability to render vector graphics.
      </p>

      <p>There are extensions for sending raster graphics with terminals,
      ranging from sixels through iterm2 base64 upload to kitty - that permit
      uploading buffers. With the increased pixel density of modern displays
      sending full framebuffers over the wire is too expensive for updating a
      buffer. <b>WARNING:</b> ctx is a work in progress, some terminal
      interactions are wonky - and display latency is good only for localized
      changes like text editing - global scrolling works less well, ctx is also
      relying on stb_image for image decoding support as well as providing
      in-band access to your microphone.
      </p>

      <img style='max-width:100%' src='terminal.png'/>

      <p>When programming in DOS or with SVGAlib the mono-spaced text
      rectangle can be upgraded to graphics mode. Similarly terminals have
      also not only provided a grid of monospaced text. Examples are DECs VTs
      with ReGIS, tektronix, BBSs with RIPscript and in some ways Display
      PostScript and NEWS.</p>

      <p>The ctx terminal adds an escape code <tt>\e[?200h</tt>which opens a
      2D vector drawing context with coordinate origin at the start of the
      current line. After this command has been issued, the terminal is no
      longer in ANSI/VT mode but in ctx mode, and commands according to the
      <a href='protocol/'>ctx protocol</a> are accepted. This protocol
      is a superset of the SVG path data format, which includes an encoding
      of the 2D canvas context API. Commands have a long form in additon to
      the short, so for verbosity (and ease of prototyping), 
      <tt>moveTo</tt>,<tt>curveTo</tt> can be used in place of <tt>m</tt>
      and <tt>l</tt> in addition <tt>(</tt>,<tt>,</tt>,<tt>)</tt> and
      <tt>;</tt> are as a bonus treated as whitespace making
      some snippets almost copy pastable with javascript bits of code
      the parser for this format also supports suffixes, the
      <a href='https://ctx.graphics/file/clients/clock.sh.html'>clock.sh</a>
      example uses this to create a clock proportional to the size
      of the terminal.
      </p>
      <img style='max-width:100%' src='clock.sh.png'/>

      <p>The ctx parser in the terminal that clock.sh creates a
      binary in-memory dawlist.

      This drawlist is played back
      in-place during the drawing commands used to draw the terminal
      with ctx. The terminal and its clients are thus merged into
      a single drawlist - which can include multiple tabs/windows.</p>

      <p>The single drawlist is used for read-only access by independent
      worker-threads.  The framebuffer to update is split into a grid (of at
      least 4 by 4) where each cell is a render job. Hashes of the drawlist
      are computed in parallel for all cells - and the cells where the hash
      differs from the last update are spread among the render threads.
      This permits for low latency updates for small changes, it is less
      optimal for fullscreen scrolling of large buffers. A cache that captures
      the rasterization of smallish shapes is currently disabled, since it
      glitches under threading - disabling it has the advantage of the threads
      being fully independent.
      </p>

      <p>One of ctx' backends in addition to SDL2 and linux framebuffer
      is the ctx backend which outputs the ctx
      protocol on stdout and accepts keyboard/pointer input either as
      standard terminal escape sequences or in a passthrough mode of ctx' own
      event format, inherited - among other bits - from <a
              href='https://github.com/hodefoting/mrg'>microraptor gui</a>.

      Pointer events can be handled as global events like the ones
      delivered to the canvas element in HTML. But a better abstraction
      can be event callbacks registered for the active path under the
      current transform. Ctx maintains a list of these in draw order
      and examines them from to back for bounding box (and NYI inPath)
      and delivers events - with the ability to stop propagation when
      a later registered handler wants to override earlier registered
      ones.
      </p>

      <p>Successive frames become a long string of rendering commands, instead
      of sending the full frames ctx transmits a detailed diff about how to construct the frame from literal text spans and copies form the previous decoded frame.
      </p>
      -->

      <!--
      <p>ctx has some <a href='#bugs'>known bugs</a>/shortcoming, on one
      important ergonomic measure, in this regard ctx seem to already be
      competetive with GPU accelerated terminals.  Due to how framebuffer
      caching is done latency is higher with large updates and scrolling than
      without. It still is almost nice enough for the main author to be
      configured as his systems default terminal - but not quite.
      </p>

      <img src='latency-openbox.png' style='width:48%;float:right;padding-left:1em'/>

      <p>The benchmarks to the right are shown in <a href='https://github.com/pavelfatin/typometer'>typometer</a>, a utility to measure time from
      keyboard event to display update. The benchmarks have been done under
      the Xorg session with openbox on a debian system. ctx is using the SDL2
      backend and is thus having higher overhead than should be neccesary
      using a more dedicated backend.</p>

      <br style='clear:both;'/>

      <img src='latency.png' style='width:48%;float:right;padding-left:1em;'/>

      <p>The measurements to the right are done under an xorg session of
      GNOME, the extra steps of compositing does increase latency somewhat.</p>

      <br style='clear:both;'/>
      -->

      <h3>Features and references</h3>

      <dl>
         <dt><a href='https://html.spec.whatwg.org/#2dcontext'>HTML5 Canvas 2D Context</a></dt><dd>Easily bindable C API and protocol builds directly on this standard.
      Compositing and blending is according to <a
      href='https://drafts.fxtf.org/compositing/'>Compositing and Blending
Level 2</a>; ctx goes further than the standard and permits all blending modes
to be combined with all compositing modes.
         </dd>

         <dt>Small footprint</dt><dd>Can be tuned for <a
                 href='mcu/'>microcontrollers</a> down to ~5kb of RAM + 30kb
         of code + 12kb of fontdata, combined with immediate mode UI that can
         be re-run, it is sufficient to have a framebuffer covering one
         scanline - making microcontrollers with 8kb of RAM a possible
         target - this has not yet been attempted. The desktop build of ctx
         is more wasteful with duplicated code paths compiled for different
         x86_64 SIMD capabilities.</dd>

         <dt>Threaded/deferred rendering</dt><dd>The compact ctx protocol - in both text and binary form is a serialization of HTML5 Canvas 2D context API with
         extensions.
         Thes drawlist representations are used for larger than RAM
         framebuffers on microcontrollers, multi threaded SDL2 and /dev/fb0
         rendering and network transparent rendering inside ctx terminal. When
         used for graphical clients inside terminals; ctx is even applying
         inter-frame compression; building the current frames drawlist out of
         fragments of the preceding (reference) frames drawlist.
         .</dd>

         <dt>utf8 native</dt><dd>Ligature handling is missing, and beyond
           vttest charset support is not good and RTL is missing -
           harfbuzz intergration can fix this and more. Also currently
           lacking color emoji. The most efficient font format is the
           binary representation of the ctx protocol.</dd>

         <dt>VT4xx, ECMA-48</dt><dd>Almost full vt100 and vt220 <a href='terminal/escape-sequences.html'>escape sequence handling</a>, scrollback, bracketed paste, 256 and 24bit colors are supported - as well as a growing subset of vt400 and other relevant terminal escape sequences.</dd>
         <dt><a href='https://pippin.gimp.org/ametameric/'>ametameric palette</a></dt>
              <dd>The terminal 16 color palette is optimized for legibility for both trichromats and dichromats</dd>
              <dt><a href='https://en.wikipedia.org/wiki/Sixel'>sixels</a></dt><dd>DEC terminal family standard for raster graphics transfer</dd>
              <dt><a href='https://sw.kovidgoyal.net/kitty/graphics-protocol.html'>kitty graphics</a></dt><dd>kitty style raster graphics transfer</dd> 
              <dt><a href='https://iterm2.com/documentation-images.html'>iterm2 inline images</a></dt><dd>iterm2 style raster grarphics transfer</dd>


         <dt>/dev/fb0</dt><dd>Both ctx as a terminal/platform and
         applications built with the ctx library can run
         directly on the linux framebuffer without X/wayland, for it to be
         fast a fast framebuffer is needed.
         </dd>

         <dt>RGB and CMYK, 8pc and 32bit floating point</dt><dd>Already
         supporting RGB332, 565 and grayscale modes with generic code
         that also will handle more components than CMYKA - the
         protocol/API has provisions for colorspaces but proper conversions are
         not done yet.</dd>

         <dt><a href='https://github.com/hodefoting/atty/'>atty</a></dt>
              <dd>audio recording and playback (only raw pcm for now, opus codec NYI)</dd>

         <dt><a href='https://github.com/nothings/stb/blob/master/stb_truetype.h'>stb_truetype.h</a></dt><dd>If the declarations for stb_truetype are
         included before ctx.h - functions to load fonts from TTF/OTF files
         become available.</dd>

         <dt><a href='https://libsdl.org/'>SDL2</a></dt><dd>Optional backend that works better than the framebuffer that gets included when SDL.h is included before ctx.h</dd>

         <dt><a href='https://cairographics.org/'>cairo</a></dt><dd>support code to render to cairo contexts if cairo.h is included before ctx.h, useful for conformance verfication and SVG and PDF output.</dd>
      </dl>

      <h3>git</h3>
      <p>Development of ctx happens in a mono-repo, which contains a split up source-tree for the rasterizer/protocol that ends up in the single-header ctx.h files, a tool to generate ctx format subsetted fonts from TTF/OTF files, the sources for a client/terminal multi-plexer - as well as demo applications for the platform.
      </p>

      <pre>$ git clone <a href='https://ctx.graphics/.git'>https://ctx.graphics/.git</a>
$ cd ctx.graphics
$ make</pre>

      <h3 id='downloads'>Downloads</h3>

      <p>There is no tarball releases yet, but the development version
      can be cloned and contains some example/test clients in C and bash,
      if you've got the development headers for SDL2 the following
      builds a ctx binary.
      </p>

      <table>
              <tr><td style='width:14em'><a href='ctx.h'>ctx.h</a><td>760K</td><td>The singleheader library ctx.</tr>
              <tr><td><a href='ctx-font-regular.h'>ctx-font-regular.h</a><td>128K</td><td>Example font to use with ctx, to be a true single header solution - the ascii subset of this is included by default.</td></tr>
              <!--<tr><td><a href='test-size.c'>test-size.c</a></td><td>example</td></tr>-->
              <tr><td><a href='binaries/ctx-x86_64-SDL2'>ctx-x86_64-SDL2</a></td><td>ELF 64bit binary for linux dynamically linked against SDL2, should work in most distros.</tr>
              <tr><td><a href='binaries/ctx-x86_64-static'>ctx-x86_64-static</a></td><td>64bit static linux binary - should work in more distros, but has only /dev/fb0 and braille rendering.</tr>
              <tr><td><a href='binaries/ctx-i486-static'>ctx-i486-static</a></td><td>32bit static linux binary - should work in more distros, but has only /dev/fb0 and braille rendering.</tr>
      </table>


<h2 id='license'>license and funding</h2>
<p> The terminal is available under <a
        href='https://www.gnu.org/licenses/gpl-3.0.en.html'>GPLv3+</a>, and
ctx.h is available under <a
        href='https://www.gnu.org/licenses/lgpl-3.0.en.html'>LGPLv3+</a> you
can encourage continued development of ctx and dissimilar technologies by
financially supporting me, <a href='https://pippin.gimp.org'>Øyvind Kolås</a> who is doing independent pro-bono R&amp;D through
       <a href='https:/pippin.gimp.org/funding/'>patreon</a> and
       similar. If my income through such sources is above 4000USD per
               month for a year, or a similar amount in shorter time the
          protocol and rasterizer parts of ctx will be relicensed under
          the <a
href='https://opensource.org/licenses/ISC'>ISC license</a>.  </p>

        <h2 id='bugs'>bugs</h2>
        <p>The current status of ctx is beyond proof of concept - but
        still does not fully realize a minimal system demonstrating
        it's capabilities - some features are also broken and need
        repair - and for third party use probably more urgently
        than the following wishlist. When this list is nearing 0
        it is time for a tarball release of ctx - event if the
        single header ctx.h already is the rolling release.
        </p>
        <ul>
          <li>clip does not clip event boxes/shapes</li>
          <li>clip is not well behaved across save/restore - doing a clip of a 0x0 rectangle is currently recognized as "reset clip"</li>
          <li>arc not well behaved for edge-cases around full-circle</li>
          <li>pastes are without newlines/tabs</li>
          <li>in_fill is using bounding box - and most reliably works with rectangle.</li>
          <li>radial gradient is only using one center</li>
          <li>dimensions of drop-shadow are not transformed</li>
          <li>some terminal escape sequences should be recognized
              also in ctx-mode, this would give a way of setting colors
              from terminal palette.</li>

	  <li>miter limit (unless round joins are used, all corners are mitered now)</li>
          <li>dash pattern for stroking is missing</li>
          <li>fbdev not properly redrawn upon vt switch</li>
          <li>cursor keys incorrect (not passing vttest) in vt52 mode</li>
          <li>pty throughput seems lower than desired when running under framebuffer - for uses like streaming audio, uploading bitmaps and possibly encoded video streams improving this is crucial. For now this means also local rendering benefits from cross-frame compression.</li>
          </ul>
        </li>
        </ul>
        <h2 id='future'>some potential improvements</h2>
	<ul>
        <li>improved performance</li>
	<li>glyph fallbacks</li>
        <li>number of render threads changeable at runtime (and automatically due to load)</li>
        <li>analytical instead of raster clipping</li>
        <li>Ensure maximum bandwidth for pty's in terminals - probably
        with a separate UI thread.</li>
        <li>texture upload as part of terminal protocol</li>
        <li>terminal rewrap on resize</li>
        <li>swap uses of cairo in <a href='http://gegl.org'>GEGL</a> with ctx</li>
        <li>ICC color management (provisions have been made in the API for this,
                but RGBtoRGB and CMYKtoRGB RGBtoCMYK conversions are currently
                done naively, instead of using <a href='http://gegl.org/babl/'>babl</a>.)</li>
        <li>websockets + js + HTML5 Canvas renderer/client for protocols</li>
        <li>wayland/libinput support</li>
        <li>DRM backend - for likely faster graphics than /dev/fb</li>
        <li>bindings to a javascript engine like quickjs, for running canvas js content as
            apps.</li>
        <li>(optional) use of floating point instead of fixed point in rasterizer.</li>
        <li>faster 1d-gaussian blur for shadow blur</li>
        <li>SVG/HTML/CSS parsing renderer (in progress, with code coming from mrg and being cleaned up) - doing this as a javascript client instead would be neat.</li>
        <li>PDF/SVG generation (in addition to existing cairo integration)</li>
        <li>Add API for integrating device-N with RGB/CMYK through <a href='http://pippin.gimp.org/color-simulator/'>coloritto</a></li>
        <li>32bit float coverage from rasterizer - right now we support 32f images; but composite them with 8bit alpha masks.</li>
        <li>More SIMD code (the common RGBA8 cases for AVX2 are the only bit
            covered thus far, for floating point formats making the
            existing code more autovectorizer friendly is a priority.)</li>
        <li>A GPU renderer, using pathfinder or similar HTML5 2d canvas matching library.</li>
	</ul>
<!--
        <h3 id='example'>example code</h3>
<pre>

#include &lt;stdint.h&gt;

#define CTX_IMPLEMENTATION

#include "<a href='ctx.h'>ctx.h</a>"

#define WIDTH    72
#define HEIGHT   24

uint8_t pixels[WIDTH*HEIGHT*4];

int main (int argc, char **argv)
{
  char *utf8 = "hello\nctx\n";
  Ctx *ctx = ctx_new_for_framebuffer (
    pixels, WIDTH, HEIGHT, WIDTH*4,
    CTX_FORMAT_RGBA8);

  ctx_rgba        (ctx, 0.5, 0.5, 0.5, 1);
  ctx_rectangle   (ctx, 0, 0, 80, 24);
  ctx_fill        (ctx);
  ctx_move_to     (ctx, 10, 9);
  ctx_font_size   (ctx, 12);
  ctx_line_width  (ctx, 2);
  ctx_rgba        (ctx, 0, 0, 0, 1);
  ctx_text_stroke (ctx, utf8);
  ctx_rgba        (ctx, 1,0, 1.0, 1.0, 1.0);
  ctx_move_to     (ctx, 10, 9);
  ctx_text        (ctx, utf8);
  ctx_free        (ctx);

  static char *utf8_gray_scale[]={" ","░","▒","▓","█","█", NULL};
  int no=0;
  for (int y= 0; y &lt; HEIGHT; y++)
  {
    for (int x = 0; x &lt; WIDTH; x++, no+=4)
      printf ("%s", utf8_gray_scale[5-(int)CTX_CLAMP(pixels[no+1]/255.0*6.0, 0, 5)]);
    printf ("\n");
  }

  return 0;
}
</pre>
which outputs (the rightmost column of pixels is a bug):
<pre>
~/src/ctx/tests$ ./test-size 
▓▓▓▓▓▓▓▓▓▓▓█▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓██▓▓█ █▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓██ ██████████▓██▓▓▓██▓▓██▓████▓▓█████▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓█░  ░█ ██░░ ░██ █▓█ █   ▓█▒  ███   ▓▓   █▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓██ ███ ██ ▓█░██░███░█▓▓██▓░██░██░████▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ █▓█ ██░██▓▓█▓▒█▒▓█▓▒██░▓██░▓█ ▓███▒██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ █▓█ ██░██▓▓██ █ ██▓▓██░▒▓▓▓███▒░▒█▒█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ ███ ██░██▓▓██▒░▒██▓▓██▒▒████████░█▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█▒░▒█ ██░██▓▓██▓ █▓██░░██░░▒░█▓░▒░▓██░░█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓█████▓██▓▓██▓██ █▓▓████▓██████████▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓ █▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█ █▓▓▓▓▓▓▓▓▓▓▓▓▓██░░█▓▓▓▓▓▓▓▓▓▓▓█▒▓█▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓████▓▓▓█████ ███▓▓▓████▓▓▓▓█░███████▓▓████▓█▒▓███▓▓████▓▓████
▓▓▓▓▓▓▓▓▓▓██▒▒▓███   ▓█ ▒ ░█▓█▒  ██▓▓█▒  ░█▓  ████  ▒██▒░  ███   ▓██   █
▓▓▓▓▓▓▓▓▓██░██▒██▒▓████ ▓█▒▓█▓▒██░█▓▓██░███░██░██░██▒▓█▒░██░█████░██████
▓▓▓▓▓▓▓▓▓█▓▒██▓▒█ █▓▓▓█ ███▒█░███░█▓▓▓█░██▓▓██▓▓█ ███░█▒▓██▒███▓▓░▓███░█
▓▓▓▓▓▓▓▓▓█▓▒█████ █▓▓▓█ ███▒█░█▓█░█▓▓▓█░██▒▓██▓▓█░███░█▒▓██▒▓█ ██▒▓██░▓█
▓▓▓▓▓▓▓▓▓█▓░█████░█████ ███▒█░▓██ █▓▓▓█░██▓░██░██ ██▓░█▒▒██░██░██░▓█▒▒██
▓▓▓▓▓▓▓▓▓▓█▓░▒░▓██ ▒░██ ███▒██░░ ▓█▓▓▓█░█▓█▒  ▒██▓ ░░██▒░▒░▒██░░░▒▓█ ▒▒█
▓▓▓▓▓▓▓▓▓▓▓█████▓███████▓▓██▓▓████▓▓▓▓▓██▓▓████▓▓████▓██████▓▓██████████
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
</pre>

<p>To fetch, build, and run ctx, and an example similar to the above
run the following:

<pre>
mkdir foo;cd foo;wget http://ctx.graphics/{ctx.h,ctx-font-regular.h,hello.c};make hello &amp;&amp; ./hello</pre>
</p>

  -->
              </div>
      </body>
</html>
