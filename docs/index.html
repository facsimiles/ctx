<html>
    <head><title>ctx - vector graphics terminal</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type='text/css'>
      @import url(ctx.css);
    </style>
  </head>

  <body>
     <div id='menu'>
              <a href='https://ctx.graphics/'>ctx</a>
              <a href='https://ctx.graphics/.git/'>git</a>
              <a href='#downloads'>downloads</a>
              <br/>
              <a href='rasterizer/'>rasterizer</a>
              <a href='protocol/'>protocol</a>
              <a href='#future'>future</a>
              <a href='#license'>license</a>
              <br/>
              <a href='mcu/'>videos</a>
              <a href='color/'>color</a>
              <a href='eink/'>eink</a>
              <a href='tests/'>tests</a>
              <a href='glitch/'>glitch</a>
      </div>

      <div id='page'>
      <img style='max-width:100%' src='tests/png-640x240/ctx.png'/>

      <p>ctx is an audio-capable 2D vector graphics terminal. A <a
        href='protocol/'>protocol</a> serializing HTML5 canvas 2D context
      as SVG path data. And a minimal application development platform, the
      terminal itself is written in ctx and can be self-hosted. </p>

      <a href='pid1.png'><img style='max-width:100%' src='pid1.png'/></a>
     
      <p>The self-contained static builds are sufficient to run minimalistic
      desktop+shells only sessions with very low RAM requirements.</p>

      <!--
good reference https://ttssh2.osdn.jp/manual/4/en/about/ctrlseq.html
      -->

      <!--
      <p>ctx is a configurable and <a href='mcu/'>lightweight</a> 2D vector
      graphics stack with focus on remote and deferred rendering building on
      top of the HTML5 canvas 2D context
      specification. The project provides as single header library
      which implements both a binary and textual <a
      href='protocol/'>drawlist protocol</a>. The ctx single-header
      library provides APIs for registering keybindings and pointer events
      with callbacks in user-relative coordinates. Events and rendering are
      abstracted for linux framebuffer, SDL2, braille in terminal and running
      in the ctx terminal. The ctx terminal is the binary built in the
      toplevel of a <a href='/.git/'>ctx git</a> checkout. This terminal
      serves as a demanding example for app-development with ctx, it used to
      be faster - but peformance of minimal framebuffer touching has been
      replaced with well-formed vector output - for /dev/fb0 usage fbterm is
      a *lot* faster - but lacks the richer media of ctx, which permits the terminal to
      run inside itself with minimal overhead. From within the terminal even
      <a href='https://ctx.graphics/file/clients/clock.sh.html'>shell
      scripts</a> get the ability to render vector graphics.
      </p>

      <p>There are extensions for sending raster graphics with terminals,
      ranging from sixels through iterm2 base64 upload to kitty - that permit
      uploading buffers. With the increased pixel density of modern displays
      sending full framebuffers over the wire is too expensive for updating a
      buffer. <b>WARNING:</b> ctx is a work in progress, some terminal
      interactions are wonky - and display latency is good only for localized
      changes like text editing - global scrolling works less well, ctx is also
      relying on stb_image for image decoding support as well as providing
      in-band access to your microphone.
      </p>

      <img style='max-width:100%' src='terminal.png'/>

      <p>When programming in DOS or with SVGAlib the mono-spaced text
      rectangle can be upgraded to graphics mode. Similarly terminals have
      also not only provided a grid of monospaced text. Examples are DECs VTs
      with ReGIS, tektronix, BBSs with RIPscript and in some ways Display
      PostScript and NEWS.</p>

      <p>The ctx terminal adds an escape code <tt>\e[?200h</tt>which opens a
      2D vector drawing context with coordinate origin at the start of the
      current line. After this command has been issued, the terminal is no
      longer in ANSI/VT mode but in ctx mode, and commands according to the
      <a href='protocol/'>ctx protocol</a> are accepted. This protocol
      is a superset of the SVG path data format, which includes an encoding
      of the 2D canvas context API. Commands have a long form in additon to
      the short, so for verbosity (and ease of prototyping), 
      <tt>moveTo</tt>,<tt>curveTo</tt> can be used in place of <tt>m</tt>
      and <tt>l</tt> in addition <tt>(</tt>,<tt>,</tt>,<tt>)</tt> and
      <tt>;</tt> are as a bonus treated as whitespace making
      some snippets almost copy pastable with javascript bits of code
      the parser for this format also supports suffixes, the
      <a href='https://ctx.graphics/file/clients/clock.sh.html'>clock.sh</a>
      example uses this to create a clock proportional to the size
      of the terminal.
      </p>
      <img style='max-width:100%' src='clock.sh.png'/>

      <p>The ctx parser in the terminal that clock.sh creates a
      binary in-memory dawlist.

      This drawlist is played back
      in-place during the drawing commands used to draw the terminal
      with ctx. The terminal and its clients are thus merged into
      a single drawlist - which can include multiple tabs/windows.</p>

      <p>The single drawlist is used for read-only access by independent
      worker-threads.  The framebuffer to update is split into a grid (of at
      least 4 by 4) where each cell is a render job. Hashes of the drawlist
      are computed in parallel for all cells - and the cells where the hash
      differs from the last update are spread among the render threads.
      This permits for low latency updates for small changes, it is less
      optimal for fullscreen scrolling of large buffers. A cache that captures
      the rasterization of smallish shapes is currently disabled, since it
      glitches under threading - disabling it has the advantage of the threads
      being fully independent.
      </p>

      <p>One of ctx' backends in addition to SDL2 and linux framebuffer
      is the ctx backend which outputs the ctx
      protocol on stdout and accepts keyboard/pointer input either as
      standard terminal escape sequences or in a passthrough mode of ctx' own
      event format, inherited - among other bits - from <a
              href='https://github.com/hodefoting/mrg'>microraptor gui</a>.

      Pointer events can be handled as global events like the ones
      delivered to the canvas element in HTML. But a better abstraction
      can be event callbacks registered for the active path under the
      current transform. Ctx maintains a list of these in draw order
      and examines them from to back for bounding box (and NYI inPath)
      and delivers events - with the ability to stop propagation when
      a later registered handler wants to override earlier registered
      ones.
      </p>

      <p>Successive frames become a long string of rendering commands, instead
      of sending the full frames ctx transmits a detailed diff about how to construct the frame from literal text spans and copies form the previous decoded frame.
      </p>
      -->

      <!--
      <p>ctx has some <a href='#bugs'>known bugs</a>/shortcoming, on one
      important ergonomic measure, in this regard ctx seem to already be
      competetive with GPU accelerated terminals.  Due to how framebuffer
      caching is done latency is higher with large updates and scrolling than
      without. It still is almost nice enough for the main author to be
      configured as his systems default terminal - but not quite.
      </p>

      <img src='latency-openbox.png' style='width:48%;float:right;padding-left:1em'/>

      <p>The benchmarks to the right are shown in <a href='https://github.com/pavelfatin/typometer'>typometer</a>, a utility to measure time from
      keyboard event to display update. The benchmarks have been done under
      the Xorg session with openbox on a debian system. ctx is using the SDL2
      backend and is thus having higher overhead than should be neccesary
      using a more dedicated backend.</p>

      <br style='clear:both;'/>

      <img src='latency.png' style='width:48%;float:right;padding-left:1em;'/>

      <p>The measurements to the right are done under an xorg session of
      GNOME, the extra steps of compositing does increase latency somewhat.</p>

      <br style='clear:both;'/>
      -->

      <h3>Features and references</h3>

      <dl>
         <dt><a href='https://html.spec.whatwg.org/#2dcontext'>HTML5 Canvas 2D Context</a></dt><dd>Easily bindable C API and protocol builds directly on this standard.
      Compositing and blending is according to <a
      href='https://drafts.fxtf.org/compositing/'>Compositing and Blending
Level 2</a>; ctx goes further than the standard and permits all blending modes
to be combined with all compositing modes.
         </dd>

         <dt>backends: ctx, DRM, fbdev, SDL2, braille<dt>
         <dd>ctx comes with 5 main backends, the ctx backend renders the
             ctx protocol to stdout, and reads input - it is meant to
             be used from the ctx terminal. DRM and fbdev are available
             without any dependencies in the static builds, this
             backend - like the braille backend, take keyboard input
             from stdin; mouse events are read from /dev/input/mice.
             The SDL2 backend permits using ctx clients under wayland/X11.
         </dd>


         <dt>RGB and CMYK, 8pc and 32bit floating point</dt><dd>
         Supporting RGB332, RGB565 and grayscale + 1bit mode render targets.
         ICC based management of RGB user/device spaces is supported through <a href='https://gegl.org/babl/'>babl</a>.
         </p>

         <dt>deferred rendering</dt><dd>Tokenizing the rasterization as a protocol is core to ctx' operation. Issuing a draw command prepares a token that is either appended to a drawlist or acted upon immediately; depending on the configuration of the context. Drawlists can be converted to both compact and verbose textual representation with little overhead.

         These drawlist representations are used for scanline/chunk-based
         rendering on microcontrollers where framebuffer is to large to fit in
         RAM and <a href='caching-and-threading/'>threaded cached rendering</a>
         through SDL2 and /dev/fb0 backends and network transparent rendering
         inside ctx terminal.
         .</dd>

         <dt>text rendering</dt><dd>UTF8 native, there is three font backends
             driven by stb_trutetype reading glyph paths on demand from
             a TTF/OTF file loaded in RAM/ROM.<br/>
             Using binary ctx drawlist representation, separated by '@'
             define-glyph commands.
             <br/>
             And an experimental backend permits rendering each glyph loaded
             on-the fly from the filesystem as ctx ascii protocol, combined
             with a UI shape editor, ctx would have a live font-editor.
             <br/>
             The text-shaping is currently limited to horizontal advances +
             horizontal kerning, no ligatures - interacting directly with
             harfbuzz could give us wider support.
         </dd>

         <dt>Small footprint</dt><dd>Can be tuned for <a
                 href='mcu/'>microcontrollers</a> down to ~7kb of RAM + 30kb
         of code + 12kb of fontdata, combined with immediate mode UI that can
         be re-run, it is sufficient to have a framebuffer covering one
         or a few scanlines. More RAM permits more flexible arrangement
         of more components using the CTX protocol.
         </dd>

         <dt>Portable</dt><dd>The core rasterizer is C99 code that also
                 compiles as C++, with simple make basd build system and only
                 optional dependencies, and thus should run on most CPU
         architectures.</dd>

         <dt>VT4xx, ECMA-48</dt><dd>Almost full vt100 and vt220 <a href='terminal/escape-sequences.html'>escape sequence handling</a>, scrollback, like xterm, dterm window manipulation (among tabs/clients), bracketed paste, 256 and 24bit colors are supported - as well as a growing subset of vt420 and other relevant terminal escape sequences.</dd>
         <dt><a href='https://pippin.gimp.org/ametameric/'>ametameric palette</a></dt>
              <dd>The terminal 16 color palette is optimized for legibility for both main varieties dichromats as well as trichromats.</dd>
              <dt><a href='https://en.wikipedia.org/wiki/Sixel'>sixels</a></dt><dd>DEC terminal family standard for raster graphics transfer</dd>
              <dt><a href='https://sw.kovidgoyal.net/kitty/graphics-protocol.html'>kitty graphics</a></dt><dd>kitty style raster graphics transfer</dd> 
              <dt><a href='https://iterm2.com/documentation-images.html'>iterm2 inline images</a></dt><dd>iterm2 style raster grarphics transfer</dd>

         <dt><a href='https://github.com/hodefoting/atty/'>atty</a></dt>
              <dd>audio recording and playback (only raw pcm for now, opus codec NYI)</dd>

         <dt><a href='https://github.com/nothings/stb/blob/master/stb_truetype.h'>stb_truetype.h</a></dt><dd>If the declarations for stb_truetype are
         included before ctx.h - functions to load fonts from TTF/OTF files
         become available.</dd>

         <dt><a href='https://libsdl.org/'>SDL2</a></dt><dd>Optional backend that works better than the framebuffer that gets included when SDL.h is included before ctx.h</dd>

         <dt><a href='https://cairographics.org/'>cairo</a></dt><dd>support code to render to cairo contexts if cairo.h is included before ctx.h, useful for conformance verfication and SVG and PDF output.</dd>
      </dl>

      <h3>git</h3>
      <p>Development of ctx happens in a mono-repo, which contains a split up source-tree for the rasterizer/protocol that ends up in the single-header ctx.h files, a tool to generate ctx format subsetted fonts from TTF/OTF files, the sources for a client/terminal multi-plexer - as well as demo applications for the platform.
      </p>

      <pre>$ git clone <a href='https://ctx.graphics/.git'>https://ctx.graphics/.git</a>
$ cd ctx.graphics
$ make</pre>

      <h3 id='downloads'>Downloads</h3>

      <p>The single header and static binaries for download are autogenerated
      together with this website each time the git repository is synched.
      </p>

      <table>
              <tr><td style='width:14em'><a href='ctx.h'>ctx.h</a><td>760K</td><td>The singleheader library ctx.</tr>
              <tr><td><a href='ctx-font-regular.h'>ctx-font-regular.h</a><td>128K</td><td>Example font to use with ctx, to be a true single header solution - the ascii subset of this is included by default.</td></tr>
              <!--<tr><td><a href='test-size.c'>test-size.c</a></td><td>example</td></tr>-->
              <!--<tr><td><a href='binaries/ctx-x86_64-SDL2'>ctx-x86_64-SDL2</a></td><td>ELF 64bit binary for linux dynamically linked against SDL2, should work in most distros.</tr>-->
              <tr><td><a href='binaries/ctx-x86_64-static'>ctx-x86_64-static</a></td><td>64bit static linux binary - should work in mant distros, but has only DRM, /dev/fb0 and braille rendering not SDL2</tr>
              <tr><td><a href='binaries/ctx-i486-static'>ctx-i486-static</a></td><td>32bit static linux binary - should work in mant distros, but has only DRM, /dev/fb0 and braille rendering not SDL2</tr>
      </table>


<h2 id='license'>license and funding</h2>
<p> The terminal is available under <a
        href='https://www.gnu.org/licenses/gpl-3.0.en.html'>GPLv3+</a>, and
ctx.h is available under <a
        href='https://www.gnu.org/licenses/lgpl-3.0.en.html'>LGPLv3+</a> you
can encourage continued development of ctx and dissimilar technologies by
financially supporting me, <a href='https://pippin.gimp.org'>Øyvind Kolås</a> who is doing independent pro-bono R&amp;D through
       <a href='https://pippin.gimp.org/funding/'>patreon</a> and
       similar. If my income through such sources is above 4000USD per
               month for a year, or a similar amount in shorter time I want
               to relicense the rasterizer and protocol parts of ctx
          under the <a
href='https://opensource.org/licenses/ISC'>ISC license</a>.  </p>

        <h2 id='bugs'>bugs</h2>
        <p>The current status of ctx is beyond proof of concept - but still
        does not fully realize a minimal system demonstrating it's capabilities
        - some features are also broken and need repair - and for third party
        use probably more urgently than the following wishlist. When this list
        is nearing 0 it is time for a tarball/versioned release of ctx. The
        single header ctx.h linked from this page is a rolling release.
        </p>
        <ul>
          <li>clip does not clip event boxes/shapes</li>

          <li>some low-level rasterizer glitches</li>
          <li>arcs doesn't fmod &gt;2PI values well</li>
          <li>in_fill is using bounding box</li>

          <li>radial gradient is only using one center</li>
          <li>dimensions of drop-shadow are not transformed</li>

	  <li>miter limit (unless round joins are used, all corners are mitered now)</li>
          <li>square line ends</li>

          <li>cursor keys incorrect (not passing vttest) in vt52 mode</li>
          <li>palm supression during typing in drm/fbdev backend</li>
        
          <li>terminal rewrap on resize</li>
          </ul>
        </li>
        </ul>

        <a href='ctx-wm.png'><img style='max-width:100%' src='ctx-wm.png'/></a>

        <h2 id='future'>directions</h2>
	<ul>
        <li>performance, there always seem to be room for improvement.</li>
        <li>continued code refactoring</li>
	<li>glyph fallbacks between fonts</li>
        <li>texture upload as part of terminal protocol</li>
        <li>swap some uses of cairo in <a href='http://gegl.org'>GEGL</a> with ctx, pass ctx data
        as buffers, or have ctx backend buffers in GEGL.</li>
        <li>binary search for glyphs in ctxf font backend, making it scale well for wide unicode coverage.</li>
        <li>websockets + js + HTML5 Canvas renderer/client for protocols</li>
        <li>wayland/libinput support</li>
        <li>analytical instead of raster clipping</li>
        <li>bindings to a javascript engine like quickjs, for running canvas js content as apps.</li>
        <li>(optional) use of floating point instead of fixed point in rasterizer.</li>
        <li>faster and correctly transformed 1d-gaussian blur for shadow blur</li>
        <li>PDF/SVG generation (in addition to existing cairo integration)</li>
        <li>Add API for integrating device-N with RGB/CMYK through <a href='http://pippin.gimp.org/color-simulator/'>coloritto</a></li>
        <li>32bit float coverage from rasterizer - right now we support 32f images/color; but composite using 8bit alpha masks.</li>
        <li>More SIMD code (the common RGBA8 cases for handled as manual
            simulated 64bit SIMD and AVX2 are the only bits covered thus
            far, for the floating point formats making the existing code more
            autovectorizer friendly is a priority.)</li>
        <li>A GPU renderer, the information needed for precomputation and
            spatial organization in many GPU rendering approaches is already
            present - alternatively backends sitting on top of exisitng
            libraries.</li>
	</ul>
<!--
        <h3 id='example'>example code</h3>
<pre>

#include &lt;stdint.h&gt;

#define CTX_IMPLEMENTATION

#include "<a href='ctx.h'>ctx.h</a>"

#define WIDTH    72
#define HEIGHT   24

uint8_t pixels[WIDTH*HEIGHT*4];

int main (int argc, char **argv)
{
  char *utf8 = "hello\nctx\n";
  Ctx *ctx = ctx_new_for_framebuffer (
    pixels, WIDTH, HEIGHT, WIDTH*4,
    CTX_FORMAT_RGBA8);

  ctx_rgba        (ctx, 0.5, 0.5, 0.5, 1);
  ctx_rectangle   (ctx, 0, 0, 80, 24);
  ctx_fill        (ctx);
  ctx_move_to     (ctx, 10, 9);
  ctx_font_size   (ctx, 12);
  ctx_line_width  (ctx, 2);
  ctx_rgba        (ctx, 0, 0, 0, 1);
  ctx_text_stroke (ctx, utf8);
  ctx_rgba        (ctx, 1,0, 1.0, 1.0, 1.0);
  ctx_move_to     (ctx, 10, 9);
  ctx_text        (ctx, utf8);
  ctx_free        (ctx);

  static char *utf8_gray_scale[]={" ","░","▒","▓","█","█", NULL};
  int no=0;
  for (int y= 0; y &lt; HEIGHT; y++)
  {
    for (int x = 0; x &lt; WIDTH; x++, no+=4)
      printf ("%s", utf8_gray_scale[5-(int)CTX_CLAMP(pixels[no+1]/255.0*6.0, 0, 5)]);
    printf ("\n");
  }

  return 0;
}
</pre>
which outputs (the rightmost column of pixels is a bug):
<pre>
~/src/ctx/tests$ ./test-size 
▓▓▓▓▓▓▓▓▓▓▓█▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓██▓▓█ █▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓██ ██████████▓██▓▓▓██▓▓██▓████▓▓█████▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓█░  ░█ ██░░ ░██ █▓█ █   ▓█▒  ███   ▓▓   █▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓██ ███ ██ ▓█░██░███░█▓▓██▓░██░██░████▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ █▓█ ██░██▓▓█▓▒█▒▓█▓▒██░▓██░▓█ ▓███▒██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ █▓█ ██░██▓▓██ █ ██▓▓██░▒▓▓▓███▒░▒█▒█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ ███ ██░██▓▓██▒░▒██▓▓██▒▒████████░█▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█▒░▒█ ██░██▓▓██▓ █▓██░░██░░▒░█▓░▒░▓██░░█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓█████▓██▓▓██▓██ █▓▓████▓██████████▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓ █▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█ █▓▓▓▓▓▓▓▓▓▓▓▓▓██░░█▓▓▓▓▓▓▓▓▓▓▓█▒▓█▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓████▓▓▓█████ ███▓▓▓████▓▓▓▓█░███████▓▓████▓█▒▓███▓▓████▓▓████
▓▓▓▓▓▓▓▓▓▓██▒▒▓███   ▓█ ▒ ░█▓█▒  ██▓▓█▒  ░█▓  ████  ▒██▒░  ███   ▓██   █
▓▓▓▓▓▓▓▓▓██░██▒██▒▓████ ▓█▒▓█▓▒██░█▓▓██░███░██░██░██▒▓█▒░██░█████░██████
▓▓▓▓▓▓▓▓▓█▓▒██▓▒█ █▓▓▓█ ███▒█░███░█▓▓▓█░██▓▓██▓▓█ ███░█▒▓██▒███▓▓░▓███░█
▓▓▓▓▓▓▓▓▓█▓▒█████ █▓▓▓█ ███▒█░█▓█░█▓▓▓█░██▒▓██▓▓█░███░█▒▓██▒▓█ ██▒▓██░▓█
▓▓▓▓▓▓▓▓▓█▓░█████░█████ ███▒█░▓██ █▓▓▓█░██▓░██░██ ██▓░█▒▒██░██░██░▓█▒▒██
▓▓▓▓▓▓▓▓▓▓█▓░▒░▓██ ▒░██ ███▒██░░ ▓█▓▓▓█░█▓█▒  ▒██▓ ░░██▒░▒░▒██░░░▒▓█ ▒▒█
▓▓▓▓▓▓▓▓▓▓▓█████▓███████▓▓██▓▓████▓▓▓▓▓██▓▓████▓▓████▓██████▓▓██████████
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
</pre>

<p>To fetch, build, and run ctx, and an example similar to the above
run the following:

<pre>
mkdir foo;cd foo;wget http://ctx.graphics/{ctx.h,ctx-font-regular.h,hello.c};make hello &amp;&amp; ./hello</pre>
</p>

  -->
              </div>
      </body>
</html>
