<html>
    <head><title>vector graphics framework</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="icon" type="image/svg+xml" href="/graphics.ctx.terminal.svg"/>
    <style type='text/css'>
      @import url(ctx.css);
      table { margin-top: .5em; }
      th { font-weight: normal; }
    </style>
  </head>

  <body>
     <div id='menu'>
              <a href='https://ctx.graphics/'>
      <img style='max-width:6em' src='graphics.ctx.terminal.svg' alt='ctx'/>
              </a>
              <a href='terminal/'>terminal</a>
              <a href='protocol/'>protocol</a>
              <a href='sdk/'>sdk</a>
              <a href='rasterizer/'>rasterizer</a>
              <br/>
              <a href='https://ctx.graphics/.git/'>git</a>
              <a href='#license'>license</a>
              <br/>
              <a href='mcu/'>mcu</a>
              <a href='tests/'>tests</a>
              <a href='glitch/'>glitch</a>
      </div>

      <div id='page'>

      <h1>vector graphics framework</h1>

      <p>ctx is a text- and media <a href='terminal/'>terminal</a>, with an
      HTML5 Canvas 2D Context and SVG inspired <a href='protocol/'>vector
      graphics protocol</a> and accompanying interactive vector graphics <a
                                                                                 href='sdk/'>SDK</a>.

      Ctx supports textures and can render to 8bit/32bit float buffers for RGB,
      grayscale and CMYK with 1/2/4bit as additions for grayscale and RGB565
      and RGB332 for RGB useful for <a href='mcu/'>microcontrollers</a> and
      with constrained RAM.
      </p>

      <p>
      Programs using ctx as a base can run on top of SDL2, directly on linux
      framebuffer+alsa. When using these backends there is additional <a
      href='caching-and-threading/'>caching and threading</a> that boost
      performance.
      </p>


      <a href='mcu/'><img style='max-width:100%' src='esp32.jpg'/></a>

      <!--
good reference https://ttssh2.osdn.jp/manual/4/en/about/ctrlseq.html
      -->

      <!--
      <p>ctx is a configurable and <a href='mcu/'>lightweight</a> 2D vector
      graphics stack with focus on remote and deferred rendering building on
      top of the HTML5 canvas 2D context
      specification. The project provides as single header library
      which implements both a binary and textual <a
      href='protocol/'>drawlist protocol</a>. The ctx single-header
      library provides APIs for registering keybindings and pointer events
      with callbacks in user-relative coordinates. Events and rendering are
      abstracted for linux framebuffer, SDL2, braille in terminal and running
      in the ctx terminal. The ctx terminal is the binary built in the
      toplevel of a <a href='/.git/'>ctx git</a> checkout. This terminal
      serves as a demanding example for app-development with ctx, it used to
      be faster - but peformance of minimal framebuffer touching has been
      replaced with well-formed vector output - for /dev/fb0 usage fbterm is
      a *lot* faster - but lacks the richer media of ctx, which permits the terminal to
      run inside itself with minimal overhead. From within the terminal even
      <a href='https://ctx.graphics/file/demos/clock.sh.html'>shell
      scripts</a> get the ability to render vector graphics.
      </p>

      <p>There are extensions for sending raster graphics with terminals,
      ranging from sixels through iterm2 base64 upload to kitty - that permit
      uploading buffers. With the increased pixel density of modern displays
      sending full framebuffers over the wire is too expensive for updating a
      buffer. <b>WARNING:</b> ctx is a work in progress, some terminal
      interactions are wonky - and display latency is good only for localized
      changes like text editing - global scrolling works less well, ctx is also
      relying on stb_image for image decoding support and providing
      in-band access to your microphone.
      </p>

      <img style='max-width:100%' src='terminal.png'/>

      <p>When programming in DOS or with SVGAlib the mono-spaced text
      rectangle can be upgraded to graphics mode. Similarly terminals have
      also not only provided a grid of monospaced text. Examples are DECs VTs
      with ReGIS, tektronix, BBSs with RIPscript and in some ways Display
      PostScript and NEWS.</p>

      <p>The ctx terminal adds an escape code <tt>\e[?200h</tt>which opens a
      2D vector drawing context with coordinate origin at the start of the
      current line. After this command has been issued, the terminal is no
      longer in ANSI/VT mode but in ctx mode, and commands according to the
      <a href='protocol/'>ctx protocol</a> are accepted. This protocol
      is a superset of the SVG path data format, which includes an encoding
      of the 2D canvas context API. Commands have a long form in additon to
      the short, so for verbosity (and ease of prototyping), 
      <tt>moveTo</tt>,<tt>curveTo</tt> can be used in place of <tt>m</tt>
      and <tt>l</tt> in addition <tt>(</tt>,<tt>,</tt>,<tt>)</tt> and
      <tt>;</tt> are as a bonus treated as whitespace making
      some snippets almost copy pastable with javascript bits of code
      the parser for this format also supports suffixes, the
      <a href='https://ctx.graphics/file/demos/clock.sh.html'>clock.sh</a>
      example uses this to create a clock proportional to the size
      of the terminal.
      </p>
      <img style='max-width:100%' src='clock.sh.png'/>

      <p>The ctx parser in the terminal that clock.sh creates a
      binary in-memory dawlist.

      This drawlist is played back
      in-place during the drawing commands used to draw the terminal
      with ctx. The terminal and its clients are thus merged into
      a single drawlist - which can include multiple tabs/windows.</p>

      <p>The single drawlist is used for read-only access by independent
      worker-threads.  The framebuffer to update is split into a grid (of at
      least 4 by 4) where each cell is a render job. Hashes of the drawlist
      are computed in parallel for all cells - and the cells where the hash
      differs from the last update are spread among the render threads.
      This permits for low latency updates for small changes, it is less
      optimal for fullscreen scrolling of large buffers. A cache that captures
      the rasterization of smallish shapes is currently disabled, since it
      glitches under threading - disabling it has the advantage of the threads
      being fully independent.
      </p>

      <p>One of ctx' backends in addition to SDL2 and linux framebuffer
      is the ctx backend which outputs the ctx
      protocol on stdout and accepts keyboard/pointer input either as
      standard terminal escape sequences or in a passthrough mode of ctx' own
      event format, inherited - among other bits - from <a
              href='https://github.com/hodefoting/mrg'>microraptor gui</a>.

      Pointer events can be handled as global events like the ones
      delivered to the canvas element in HTML. But a better abstraction
      can be event callbacks registered for the active path under the
      current transform. Ctx maintains a list of these in draw order
      and examines them from to back for bounding box (and NYI inPath)
      and delivers events - with the ability to stop propagation when
      a later registered handler wants to override earlier registered
      ones.
      </p>

      <p>Successive frames become a long string of rendering commands, instead
      of sending the full frames ctx transmits a detailed diff about how to construct the frame from literal text spans and copies form the previous decoded frame.
      </p>
      -->

      <!--
      <p>ctx has some <a href='#bugs'>known bugs</a>/shortcoming, on one
      important ergonomic measure, in this regard ctx seem to already be
      competetive with GPU accelerated terminals.  Due to how framebuffer
      caching is done latency is higher with large updates and scrolling than
      without. It still is almost nice enough for the main author to be
      configured as his systems default terminal - but not quite.
      </p>

      <img src='latency-openbox.png' style='width:48%;float:right;padding-left:1em'/>

      <p>The benchmarks to the right are shown in <a href='https://github.com/pavelfatin/typometer'>typometer</a>, a utility to measure time from
      keyboard event to display update. The benchmarks have been done under
      the Xorg session with openbox on a debian system. ctx is using the SDL2
      backend and is thus having higher overhead than should be neccesary
      using a more dedicated backend.</p>

      <br style='clear:both;'/>

      <img src='latency.png' style='width:48%;float:right;padding-left:1em;'/>

      <p>The measurements to the right are done under an xorg session of
      GNOME, the extra steps of compositing does increase latency somewhat.</p>

      <br style='clear:both;'/>
      -->

      <!--<h3>Features and references</h3>-->


<h2 id='license'>license and funding</h2>
<p> The terminal is available under <a
        href='https://www.gnu.org/licenses/gpl-3.0.en.html'>GPLv3+</a>, and
ctx.h is available under <a
        href='https://www.gnu.org/licenses/lgpl-3.0.en.html'>LGPLv3+</a> you
can encourage continued development of ctx and dissimilar technologies by
financially supporting me, <a href='https://pippin.gimp.org'>Øyvind Kolås</a> who is doing independent pro-bono R&amp;D through
       <a href='https://pippin.gimp.org/funding/'>patreon</a> and
       similar. If my income through such sources is above 4000USD per
               month for a year, or a similar amount in shorter time I want
               to relicense the rasterizer and protocol parts of ctx
          under the <a
href='https://opensource.org/licenses/ISC'>ISC license</a>.  </p>

<!--
        <h3 id='example'>example code</h3>
<pre>

#include &lt;stdint.h&gt;

#define CTX_IMPLEMENTATION

#include "<a href='ctx.h'>ctx.h</a>"

#define WIDTH    72
#define HEIGHT   24

uint8_t pixels[WIDTH*HEIGHT*4];

int main (int argc, char **argv)
{
  char *utf8 = "hello\nctx\n";
  Ctx *ctx = ctx_new_for_framebuffer (
    pixels, WIDTH, HEIGHT, WIDTH*4,
    CTX_FORMAT_RGBA8);

  ctx_rgba        (ctx, 0.5, 0.5, 0.5, 1);
  ctx_rectangle   (ctx, 0, 0, 80, 24);
  ctx_fill        (ctx);
  ctx_move_to     (ctx, 10, 9);
  ctx_font_size   (ctx, 12);
  ctx_line_width  (ctx, 2);
  ctx_rgba        (ctx, 0, 0, 0, 1);
  ctx_text_stroke (ctx, utf8);
  ctx_rgba        (ctx, 1,0, 1.0, 1.0, 1.0);
  ctx_move_to     (ctx, 10, 9);
  ctx_text        (ctx, utf8);
  ctx_free        (ctx);

  static char *utf8_gray_scale[]={" ","░","▒","▓","█","█", NULL};
  int no=0;
  for (int y= 0; y &lt; HEIGHT; y++)
  {
    for (int x = 0; x &lt; WIDTH; x++, no+=4)
      printf ("%s", utf8_gray_scale[5-(int)CTX_CLAMP(pixels[no+1]/255.0*6.0, 0, 5)]);
    printf ("\n");
  }

  return 0;
}
</pre>
which outputs (the rightmost column of pixels is a bug):
<pre>
~/src/ctx/tests$ ./test-size 
▓▓▓▓▓▓▓▓▓▓▓█▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓██▓▓█ █▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓██ ██████████▓██▓▓▓██▓▓██▓████▓▓█████▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓█░  ░█ ██░░ ░██ █▓█ █   ▓█▒  ███   ▓▓   █▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓██ ███ ██ ▓█░██░███░█▓▓██▓░██░██░████▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ █▓█ ██░██▓▓█▓▒█▒▓█▓▒██░▓██░▓█ ▓███▒██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ █▓█ ██░██▓▓██ █ ██▓▓██░▒▓▓▓███▒░▒█▒█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ ███ ██░██▓▓██▒░▒██▓▓██▒▒████████░█▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█▒░▒█ ██░██▓▓██▓ █▓██░░██░░▒░█▓░▒░▓██░░█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓█████▓██▓▓██▓██ █▓▓████▓██████████▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓ █▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█ █▓▓▓▓▓▓▓▓▓▓▓▓▓██░░█▓▓▓▓▓▓▓▓▓▓▓█▒▓█▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓████▓▓▓█████ ███▓▓▓████▓▓▓▓█░███████▓▓████▓█▒▓███▓▓████▓▓████
▓▓▓▓▓▓▓▓▓▓██▒▒▓███   ▓█ ▒ ░█▓█▒  ██▓▓█▒  ░█▓  ████  ▒██▒░  ███   ▓██   █
▓▓▓▓▓▓▓▓▓██░██▒██▒▓████ ▓█▒▓█▓▒██░█▓▓██░███░██░██░██▒▓█▒░██░█████░██████
▓▓▓▓▓▓▓▓▓█▓▒██▓▒█ █▓▓▓█ ███▒█░███░█▓▓▓█░██▓▓██▓▓█ ███░█▒▓██▒███▓▓░▓███░█
▓▓▓▓▓▓▓▓▓█▓▒█████ █▓▓▓█ ███▒█░█▓█░█▓▓▓█░██▒▓██▓▓█░███░█▒▓██▒▓█ ██▒▓██░▓█
▓▓▓▓▓▓▓▓▓█▓░█████░█████ ███▒█░▓██ █▓▓▓█░██▓░██░██ ██▓░█▒▒██░██░██░▓█▒▒██
▓▓▓▓▓▓▓▓▓▓█▓░▒░▓██ ▒░██ ███▒██░░ ▓█▓▓▓█░█▓█▒  ▒██▓ ░░██▒░▒░▒██░░░▒▓█ ▒▒█
▓▓▓▓▓▓▓▓▓▓▓█████▓███████▓▓██▓▓████▓▓▓▓▓██▓▓████▓▓████▓██████▓▓██████████
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
</pre>

<p>To fetch, build, and run ctx, and an example similar to the above
run the following:

<pre>
mkdir foo;cd foo;wget http://ctx.graphics/{ctx.h,ctx-font-regular.h,hello.c};make hello &amp;&amp; ./hello</pre>
</p>

  -->
              </div>
      </body>
</html>
