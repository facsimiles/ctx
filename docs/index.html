<html>
  <head><title>ctx - 2d vector graphics stack</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="icon" type="image/svg+xml" href="/graphics.ctx.terminal.svg"/>
    <style type='text/css'>
      @import url(ctx.css);
      table { margin-top: .5em; }
      th { font-weight: normal; }
    </style>
    <script src="./wasm/demo.js"></script>
  </head>

  <body lang='en'>
     <div id='menu'>

              <a href='https://ctx.graphics/'>
      <img style='max-width:6em' src='graphics.ctx.terminal.svg' alt='ctx'/>
              </a>
              <a href='terminal/'>terminal</a>
              <a href='protocol/'>protocol</a>
              <a href='sdk/'>sdk</a>
              <a href='uctx/'>uctx</a>
              <a href='rasterizer/'>rasterizer</a>
              <a href='compositing/'>compositing</a>
              <a href='performance/'>performance</a>
              <br/>
              <a href='https://ctx.graphics/.git/'>git</a>
              <a href='#license'>license</a>
              <br/>
              <a href='mcu/'>mcu</a>
              <a href='tests/'>tests</a>
              <a href='glitch/'>glitch</a>
      </div>

      <div id='page'>

      <h1>interactive 2D vector graphics protocol</h1>

      <p>ctx is an interactive 2D vector graphics protocol,
      providing remote backends and process multiplexing integrated
      with a terminal emulator/window manager; providing an end-to-end
      vector rendering framework suitable for serial links. It aims for
      rendering quality and <a href='performance/'>performance</a> with minimal
      footprint and resource usage, suitable for bare-metal use on 32bit
      microcontrollers without additional dependencies and scaling to handling
      <a href='output.pdf'>PDF</a>, floating point buffer, CMYK and
      multi-threaded rendering. The core drawing and renderings APIs are stable
      and optional event handling, DEC compatible virtual terminal, fb and event
      drivers, examples and more are included in the monorepo.
      </p>

      <p> The <a href='rasterizer/'>ctx rasterizer</a> is
      fast, portable and compact with a wide range of supported pixel encodings
      from 1bit to 32bit per pixel, in grayscale, RGB and CMYK.
      For <a href='mcu/'>microcontrollers</a> using <a href='sdk/'>C</a> or <a
              href='uctx'>micropython</a>. ctx renders to lower bitdepth
      RGB332, RGB565 variants as well as 1,2 and 4 bit per pixel grayscale is
      handled. Combined with floating point pixel encoding support and color
             management ctx scales to meet <a href='https://gegl.org/'>GEGL</a>
             and <a href='https://www.gimp.org.'>GIMP</a>s needs.</p>

      <p>ctx provides abstractions for event injection and dispatch. It
      provides hit-detection, this allows abstracting over multiple input
      devices/buttons with a mouste+keyboard abstraction. In the event
      method callback both absolute and local (At time of callback registration)
      coordinates are provided.
      </p>
      <p>
      The same API can also be used for writing applications that run inside
      the <a href='terminal/'>ctx terminal</a>, which provides escape sequences
              that enable drawing 2D vector graphics both inline, and for
              full-window applications taking over the terminal using the <a
                      href='protocol/'>ctx protocol</a>, or even on webpages
      using webassembly, for now single threaded - and without the potential
      acceleration through reuse of the rasterizer of the HTML5 Canvas.</p>

      <!--<img style='max-width:100%' alt='constant-z rescuing the sixels far far away, tolerance breaking down near framebuffer.' src='perspective.png'/>
      -->


      <img style='max-width:100%' src='esp32.jpg'/>

      <p>The ctx renderer is written in portable C, without
      inline assembly or SIMD intrinsics - but is still fast (and can
      make good use of cpu capabilities known by the C compiler, thus making
      the same code work across x86 32 and 64bit, ARM on MCUs and
      SBCs, tensilica, RISC-V and other compilers with a modern toolchain.
      The single threaded rendering performance <a
      href='performance/'>rendering performance</a> is often better than engines with
      more dedicated/manual SIMD handling.  </p>


      <p>Below is ctx compiled to WASM with emscripten (without SIMD support).
      Operating on a 640x480 canvas.
      </p>
      <canvas style='max-width:100%' width='640' height='480' id='c'>
      </canvas>

<h2 id='license'>license and funding</h2>
<p> ctx is available under <a
        href='https://www.gnu.org/licenses/lgpl-3.0.en.html'>LGPLv3+</a> you
can encourage continued development of ctx and dissimilar technologies by
financially supporting me, <a href='https://pippin.gimp.org'>Øyvind Kolås</a> who is doing independent pro-bono R&amp;D through
       <a href='https://pippin.gimp.org/funding/'>patreon</a> and
       similar. If my income through such sources is above 4000USD per month
for a year, or if someone does a one time payment of the equivalent amount for
the time I invested in ctx over the last few years, ctx could become available
under under the <a
href='https://opensource.org/licenses/ISC'>ISC license</a>.</p>

              </div>
      </body>
</html>
