<html>
    <head><title>ctx - vector graphics terminal</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type='text/css'>
      @import url(ctx.css);
      @import url(https://pippin.gimp.org/ametameric/ametamer.css?20200423);
      table { margin-top: .5em; }
      th { font-weight: normal; }
    </style>
  </head>

  <body>
     <div id='menu'>
              <a href='https://ctx.graphics/'>ctx</a>
              <a href='https://ctx.graphics/.git/'>git</a>
              <a href='#downloads'>downloads</a>
              <br/>
              <a href='rasterizer/'>rasterizer</a>
              <a href='protocol/'>protocol</a>
              <a href='#future'>future</a>
              <a href='#license'>license</a>
              <br/>
              <a href='mcu/'>videos</a>
              <a href='color/'>color</a>
              <a href='eink/'>eink</a>
              <a href='tests/'>tests</a>
              <a href='glitch/'>glitch</a>
      </div>

      <div id='page'>
      <img style='max-width:100%' src='tests/png-640x240/ctx.png'/>

      <p>ctx is a media-rich terminal and a vector graphics stack, built
      around a textual serialization <a href='protocol/'>protocol</a>. The
      textual serialization has a corresponding binary representation that
      is used by the core rasterizer as well as sharing data among threads.
      The ctx protocol is available as an extension to ANSI escape sequences
      in the ctx terminal - the terminal launched when running the ctx
      binary with no arguments. This extension allows scripts in any
      language to output vector graphics in addition to or instead of
      monospace text in each tab/window, and also provides network
      transparent rendering.</p>

      <a href='pid1.png'><img style='max-width:100%' src='pid1.png'/></a>
      <p>
      The clock in the above screenshot is <a href='https://ctx.graphics/file/clients/clock.sh.html'>a shellscript</a>.
      </p>

      <h3>Library</h3>
      <p>
      Ctx is usable as a single header library, to be dropped into a source
      tree, <a href='ctx.h'>ctx header/library</a>, it can also be installed
      system-wide.
      </p>
      
      <p>Applications written using the C library can run either inside the
      ctx terminal, or stand-alone using SDL2, fbdev/DRM or in-terminal
      braille as output.

      <p>Mouse and touch events are registered for the currently active path,
      with propagation control to earlier registered interactions.</p>

      <p>Running directly with the SDL2 or framebuffer backends
      has higher performance than going through the terminal abstraction,
      reducing this gap through tuning and refactoring is a work in progress,
      for applications the difference between 12fps and 120fps is smaller
      and small rather than global updates are done.
      </p>

      <!--
      <h3>javascript</h3>

      <p>Through the inclusion of duktape, ctx is able to
      execute some interactive HTML5 Canvases unmodified or with slight
      adaptations as native applications. One example that runs
      unmodified is <a href='https://github.com/rembound/Bubble-Shooter-HTML5'>github.com/rembound/Bubble-Shooter-HTML5</a>.
      </p>
      -->

      <h3>multiplexing</h3>

      <p>The self-contained static builds are sufficient to run minimalistic
      desktop+shells only sessions with low RAM requirements. The rasterizer
      which for multi-core use is used in parallell for multiple threads,
      started off written to fit on <a href='mcu/'>microntrollers</a>, with the
      right defines a RGBA 8bit rasterizer can be made to fit in 32kb of code
      also for 64bit x86.</p>

      <a href='mcu/'><img style='max-width:100%' src='esp32.jpg'/></a>

      <!--
good reference https://ttssh2.osdn.jp/manual/4/en/about/ctrlseq.html
      -->

      <!--
      <p>ctx is a configurable and <a href='mcu/'>lightweight</a> 2D vector
      graphics stack with focus on remote and deferred rendering building on
      top of the HTML5 canvas 2D context
      specification. The project provides as single header library
      which implements both a binary and textual <a
      href='protocol/'>drawlist protocol</a>. The ctx single-header
      library provides APIs for registering keybindings and pointer events
      with callbacks in user-relative coordinates. Events and rendering are
      abstracted for linux framebuffer, SDL2, braille in terminal and running
      in the ctx terminal. The ctx terminal is the binary built in the
      toplevel of a <a href='/.git/'>ctx git</a> checkout. This terminal
      serves as a demanding example for app-development with ctx, it used to
      be faster - but peformance of minimal framebuffer touching has been
      replaced with well-formed vector output - for /dev/fb0 usage fbterm is
      a *lot* faster - but lacks the richer media of ctx, which permits the terminal to
      run inside itself with minimal overhead. From within the terminal even
      <a href='https://ctx.graphics/file/clients/clock.sh.html'>shell
      scripts</a> get the ability to render vector graphics.
      </p>

      <p>There are extensions for sending raster graphics with terminals,
      ranging from sixels through iterm2 base64 upload to kitty - that permit
      uploading buffers. With the increased pixel density of modern displays
      sending full framebuffers over the wire is too expensive for updating a
      buffer. <b>WARNING:</b> ctx is a work in progress, some terminal
      interactions are wonky - and display latency is good only for localized
      changes like text editing - global scrolling works less well, ctx is also
      relying on stb_image for image decoding support and providing
      in-band access to your microphone.
      </p>

      <img style='max-width:100%' src='terminal.png'/>

      <p>When programming in DOS or with SVGAlib the mono-spaced text
      rectangle can be upgraded to graphics mode. Similarly terminals have
      also not only provided a grid of monospaced text. Examples are DECs VTs
      with ReGIS, tektronix, BBSs with RIPscript and in some ways Display
      PostScript and NEWS.</p>

      <p>The ctx terminal adds an escape code <tt>\e[?200h</tt>which opens a
      2D vector drawing context with coordinate origin at the start of the
      current line. After this command has been issued, the terminal is no
      longer in ANSI/VT mode but in ctx mode, and commands according to the
      <a href='protocol/'>ctx protocol</a> are accepted. This protocol
      is a superset of the SVG path data format, which includes an encoding
      of the 2D canvas context API. Commands have a long form in additon to
      the short, so for verbosity (and ease of prototyping), 
      <tt>moveTo</tt>,<tt>curveTo</tt> can be used in place of <tt>m</tt>
      and <tt>l</tt> in addition <tt>(</tt>,<tt>,</tt>,<tt>)</tt> and
      <tt>;</tt> are as a bonus treated as whitespace making
      some snippets almost copy pastable with javascript bits of code
      the parser for this format also supports suffixes, the
      <a href='https://ctx.graphics/file/clients/clock.sh.html'>clock.sh</a>
      example uses this to create a clock proportional to the size
      of the terminal.
      </p>
      <img style='max-width:100%' src='clock.sh.png'/>

      <p>The ctx parser in the terminal that clock.sh creates a
      binary in-memory dawlist.

      This drawlist is played back
      in-place during the drawing commands used to draw the terminal
      with ctx. The terminal and its clients are thus merged into
      a single drawlist - which can include multiple tabs/windows.</p>

      <p>The single drawlist is used for read-only access by independent
      worker-threads.  The framebuffer to update is split into a grid (of at
      least 4 by 4) where each cell is a render job. Hashes of the drawlist
      are computed in parallel for all cells - and the cells where the hash
      differs from the last update are spread among the render threads.
      This permits for low latency updates for small changes, it is less
      optimal for fullscreen scrolling of large buffers. A cache that captures
      the rasterization of smallish shapes is currently disabled, since it
      glitches under threading - disabling it has the advantage of the threads
      being fully independent.
      </p>

      <p>One of ctx' backends in addition to SDL2 and linux framebuffer
      is the ctx backend which outputs the ctx
      protocol on stdout and accepts keyboard/pointer input either as
      standard terminal escape sequences or in a passthrough mode of ctx' own
      event format, inherited - among other bits - from <a
              href='https://github.com/hodefoting/mrg'>microraptor gui</a>.

      Pointer events can be handled as global events like the ones
      delivered to the canvas element in HTML. But a better abstraction
      can be event callbacks registered for the active path under the
      current transform. Ctx maintains a list of these in draw order
      and examines them from to back for bounding box (and NYI inPath)
      and delivers events - with the ability to stop propagation when
      a later registered handler wants to override earlier registered
      ones.
      </p>

      <p>Successive frames become a long string of rendering commands, instead
      of sending the full frames ctx transmits a detailed diff about how to construct the frame from literal text spans and copies form the previous decoded frame.
      </p>
      -->

      <!--
      <p>ctx has some <a href='#bugs'>known bugs</a>/shortcoming, on one
      important ergonomic measure, in this regard ctx seem to already be
      competetive with GPU accelerated terminals.  Due to how framebuffer
      caching is done latency is higher with large updates and scrolling than
      without. It still is almost nice enough for the main author to be
      configured as his systems default terminal - but not quite.
      </p>

      <img src='latency-openbox.png' style='width:48%;float:right;padding-left:1em'/>

      <p>The benchmarks to the right are shown in <a href='https://github.com/pavelfatin/typometer'>typometer</a>, a utility to measure time from
      keyboard event to display update. The benchmarks have been done under
      the Xorg session with openbox on a debian system. ctx is using the SDL2
      backend and is thus having higher overhead than should be neccesary
      using a more dedicated backend.</p>

      <br style='clear:both;'/>

      <img src='latency.png' style='width:48%;float:right;padding-left:1em;'/>

      <p>The measurements to the right are done under an xorg session of
      GNOME, the extra steps of compositing does increase latency somewhat.</p>

      <br style='clear:both;'/>
      -->

      <!--<h3>Features and references</h3>-->

      <dl>
         <dt>VT4xx, ECMA-48</dt><dd>Almost full vt100 and vt220 <a href='terminal/escape-sequences.html'>escape sequence handling</a>, scrollback, like xterm, dterm window manipulation (among tabs/clients), bracketed paste, 256 and 24bit colors are supported - and a growing subset of vt420 and other relevant terminal escape sequences.</dd>

         <dt>Low-latency</dt><dd>The ctx terminal tries to re-render as
           little as possible, as fast as posisble using multiple
           threads, and SIMD when possible (AVX2 ands 64-bit-pseudo-SIMD
         implemented). Results of running typometer measuring latency under
         a composited GNOME3, numers are average milliseconds per update, lower
         is better:

           <table>
              <tr><th>terminology</th><th>mlterm</th><th>ctx</th><th>kitty</th><th>gnome-terminal</th></tr>
              <tr><td>38.2</td><td>39.8</td><td>39.4</td><td>42.6</td><td>72.0</td></tr>
           </table>
         </dd>

         <dt><a href='https://pippin.gimp.org/ametameric/' style='text-decoration:none; color: white; '>

 <span class='bg-red'>&nbsp;&nbsp;</span
        ><span class='bg-bright-red'>Am</span
        ><span class='bg-yellow'>et</span
        ><span class='bg-bright-green'>am</span
        ><span class='bg-green'>er</span
        ><span class='bg-cyan'>ic</span
        ><span class='bg-bright-cyan'>&nbsp;&nbsp;</span
        ><span class='bg-bright-blue'>&nbsp;&nbsp;</span
        ><span class='bg-blue'>&nbsp;&nbsp;</span
        ><span class='bg-magenta'>&nbsp;&nbsp;</span
        ><span class='bg-bright-magenta'>&nbsp;&nbsp;</span
        ><span class='bg-white' style='border-top:1px solid gray;border-bottom:1px solid gray;'>&nbsp;&nbsp;</span
        ><span class='bg-bright-gray'>&nbsp;&nbsp;</span
        ><span class='bg-gray'>&nbsp;&nbsp;</span
        ><span class='bg-brown'>&nbsp;&nbsp;</span
        ><span class='bg-black'>&nbsp;&nbsp;</span>
                 </a></dt>

              <dd>
                      The terminals 16 color palette called <a href='https://pippin.gimp.org/ametameric/'>ametameric</a> is optimized for legibility for both main varieties dichromats as well as trichromats.</dd>


         <dt><a href='https://html.spec.whatwg.org/#2dcontext'>HTML5 canvas 2D context</a></dt><dd>Easily bindable C API and protocol builds directly on this standard.
      Compositing and blending is according to <a
      href='https://drafts.fxtf.org/compositing/'>compositing and blending
level 2</a>; ctx goes further than the standard and permits all blending modes
to be combined with all compositing modes.
         </dd>

         <dt>backends: ctx, DRM, fbdev, SDL2, braille<dt>
         <dd>ctx comes with 5 interactive
                 backends, the <em>ctx backend</em> renders the
             ctx protocol to stdout, and reads input, this
             provides the client interface for interactive vector
             clients running in the ctx terminal.<br/>
             <em>DRM and fbdev</em> backend takes
             take keyboard input from stdin and tries to read mouse events are
             from /dev/input/mice. 
             The <em>SDL2</em> backend permits using ctx clients
             under wayland/X11 and probably other platforms.
         </dd>

         <dt>RGB and CMYK, 8pc and 32bit floating point</dt><dd>
         Supporting RGB332, RGB565 and grayscale + 1bit mode render targets.
         ICC based color management of RGB user/device spaces through <a href='https://gegl.org/babl/'>babl</a> as an optional dependency. CMYK colors can be generated on the fly
         from RGB or set and retained in CMYK mode - when set in CMYK mode the
         colors correspond directly to the device colors in CMYK mode.
         </p>

         <dt>deferred rendering</dt><dd>
         These drawlist representations are used for scanline/chunk-based
         rendering on microcontrollers where framebuffer is to large to fit in
         RAM and <a href='caching-and-threading/'>tiles and threaded rendering on multi-core systems</a>
         with SDL2 and /dev/fb0 backends and network transparent rendering
         inside ctx terminal. Another way to drive larger than RAM
         is to re-render the frame for each segment instead of buffering it,
         buffering is however useful when doing networked rendering, ctx
         can be configured and adapted to deal with a wide range of scenarios.
         .</dd>

         <dt>text rendering</dt><dd>Three font loading backends, stb_truetype, native-ctx and ctx-fs. The ctx.h header ships with a built-in native-ctx font.

          In following screenshot a text-file with the commands for the @ glyph
          is being edited in vim, with instant update across all clients. This
          massively slows down the UI but not enough to be unusuable. With
          a simple visual vector editor working directly with the ctx-protocol
          this provides for an almost complete live font-editor.
          <br/>

        <a href='ctx-wm.png'><img style='max-width:100%' src='ctx-wm.png'/></a>

          The text-shaping is currently limited to horizontal advances +
          horizontal kerning, no ligatures, RTL or vertical glyph advances -
          interacting directly with harfbuzz could give us wider support.
         </dd>


              <dt><a href='https://en.wikipedia.org/wiki/Sixel'>sixels</a></dt><dd>DEC terminal family standard for raster graphics transfer</dd>
              <dt><a href='https://sw.kovidgoyal.net/kitty/graphics-protocol.html'>kitty graphics</a></dt><dd>kitty style raster graphics transfer</dd> 
              <dt><a href='https://iterm2.com/documentation-images.html'>iterm2 inline images</a></dt><dd>iterm2 style raster grarphics transfer</dd>

         <dt><a href='https://github.com/hodefoting/atty/'>atty</a></dt>
              <dd>audio recording and playback (only raw pcm for now, opus codec NYI)</dd>

         <dt><a href='https://github.com/nothings/stb/blob/master/stb_truetype.h'>stb_truetype.h</a></dt><dd>If the declarations for stb_truetype are
         included before ctx.h - functions to load fonts from TTF/OTF files
         become available.</dd>

         <dt><a href='https://libsdl.org/'>SDL2</a></dt><dd>Optional backend and support code that that gets build when SDL.h is included before ctx.h</dd>

         <dt><a href='https://cairographics.org/'>cairo</a></dt><dd>support code to render to cairo contexts if cairo.h is included before ctx.h, useful for conformance verfication and SVG and PDF output.</dd>
      </dl>

      <h3 id='downloads'>downloads / sources</h3>

      <p>The single header and static binaries for download are autogenerated
      together with this website each time the git repository is synched.
      </p>

      <table>

              <tr><td style='width:14em'><a href='ctx.h'>ctx.h</a><td>760K</td><td>The singleheader library ctx.</tr>

              <tr><td><a href='https://ctx.graphics/.git/'>git repo</a></td><td>

                                      <pre>$ git clone <a href='https://ctx.graphics/.git/'>https://ctx.graphics/.git</a>
                                      </pre>
                                      The repository contains the sources for
                                      examples and tests, and the
                                      implementation of 2D vector rasterization
                                      and protocl parser and serializer.
                                      </td>
              </tr>

              <tr><td><a href='ctx-font-regular.h'>ctx-font-regular.h</a><td>128K</td><td>Example font to use with ctx, to be a true single header solution - the ascii subset of this is already defined in ctx.h</td></tr>
              <!--<tr><td><a href='test-size.c'>test-size.c</a></td><td>example</td></tr>-->
              <!--<tr><td><a href='binaries/ctx-x86_64-SDL2'>ctx-x86_64-SDL2</a></td><td>ELF 64bit binary for linux dynamically linked against SDL2, should work in most distros.</tr>-->
              <tr><td><a href='binaries/ctx-x86_64-static'>ctx-x86_64-static</a></td><td>64bit static linux binary - should work in many distros on framebuffer /dev/fb0 and braille backends</tr>
              <tr><td><a href='binaries/ctx-i486-static'>ctx-i486-static</a></td><td>32bit static linux binary - should work in many distros on framebuffer, /dev/fb0 and braille backends.</tr>
      </table>

<h2 id='license'>license and funding</h2>
<p> The terminal is available under <a
        href='https://www.gnu.org/licenses/gpl-3.0.en.html'>GPLv3+</a>, and
ctx.h is available under <a
        href='https://www.gnu.org/licenses/lgpl-3.0.en.html'>LGPLv3+</a> you
can encourage continued development of ctx and dissimilar technologies by
financially supporting me, <a href='https://pippin.gimp.org'>Øyvind Kolås</a> who is doing independent pro-bono R&amp;D through
       <a href='https://pippin.gimp.org/funding/'>patreon</a> and
       similar. If my income through such sources is above 4000USD per
               month for a year, or a similar amount in shorter time I want
               to relicense the rasterizer and protocol parts of ctx
          under the <a
href='https://opensource.org/licenses/ISC'>ISC license</a>.  </p>

        <h2 id='future'>future work</h2>
        <h3 id='bugs'>pressing issues</h3>
        <p>The current status of ctx is beyond proof of concept - but still
        does not fully realize a minimal system demonstrating it's capabilities
        - some features are also broken and need repair - and for third party
        use probably more urgently than the following wishlist. When this list
        is nearing 0 it is time for a tarball/versioned release of ctx. The
        single header ctx.h linked from this page is a rolling release.
        </p>
        <ul>
          <li>configure fonts</li>
          <li>use separate configured fonts for mono/italic/bold
              (keeping current fallback synthesizing code)</li>
          <li>fonts with color emoji</li>
          <li>clip does not clip event boxes/shapes</li>

          <li>some low-level rasterizer glitches</li>
          <li>in_fill is using bounding box</li>

          <li>radial gradient is only using one center</li>
          <li>dimensions of drop-shadow are incorrectly transformed</li>

          <li>changes in texture transform incorrectly picked up by hash-cache</li>

	  <li>miter limit (unless round joins are used, all corners are mitered now)</li>
          <li>square line ends</li>

          <li>palm supression during typing in drm/fbdev backend</li>
        
          <li>cursor keys incorrect (not passing vttest) in vt52 mode</li>
          <li>missing terminal content rewrapping on resize</li>
          <li>hyperlink escape sequences</li>
          </ul>
        </li>
        </ul>

        <h3>desirable improvements</h3>
	<ul>
        <li>performance, there always seem to be room for improvement.</li>
        <li>continued code clean-ups and refactoring</li>
	<li>glyph fallbacks between fonts</li>
        <li>analytical instead of raster clipping.</li>
        <li>double-width glyphs (terminal) - for non-terminal use this works, for emoji and asian scripts</li>
        <li>multi-head, both for DRM when plugging in HDMI/VGA and networked
        connect to ESP32 / html5 canvas clients.</li>
        <li>swap some uses of cairo in <a href='http://gegl.org'>GEGL</a> with ctx, pass ctx data
        as buffers, or have ctx backed buffers in GEGL.</li>
        <li>binary search for glyphs in ctxf font backend, making it scale well for wide unicode coverage.</li>
        <li>websockets + js + HTML5 Canvas renderer/client for protocols</li>
        <li>wayland/libinput support</li>
        <li>optional use of floating point instead of fixed point in rasterizer.</li>
        <li>faster and correctly transformed 1d-gaussian blur for shadow blur</li>
        <li>PDF/SVG generation (in addition to existing cairo integration)</li>
        <li>Add API for integrating device-N and spectral with RGB/CMYK through <a href='http://pippin.gimp.org/color-simulator/'>coloritto</a></li>
        <li>32bit float coverage from rasterizer - right now we support 32f images/color; but composite using 8bit alpha masks.</li>
        <li>More SIMD code (the common RGBA8 cases for handled as manual
            simulated 64bit SIMD and AVX2 are the only bits covered thus
            far, for the floating point formats making the existing code more
            autovectorizer friendly is a priority.)</li>
        <li>GPU renderer, the information needed for precomputation and
            spatial organization in many GPU rendering approaches is already
            present - alternatively backends sitting on top of exisitng
            libraries like NanoVg.
        </li>
	</ul>
<!--
        <h3 id='example'>example code</h3>
<pre>

#include &lt;stdint.h&gt;

#define CTX_IMPLEMENTATION

#include "<a href='ctx.h'>ctx.h</a>"

#define WIDTH    72
#define HEIGHT   24

uint8_t pixels[WIDTH*HEIGHT*4];

int main (int argc, char **argv)
{
  char *utf8 = "hello\nctx\n";
  Ctx *ctx = ctx_new_for_framebuffer (
    pixels, WIDTH, HEIGHT, WIDTH*4,
    CTX_FORMAT_RGBA8);

  ctx_rgba        (ctx, 0.5, 0.5, 0.5, 1);
  ctx_rectangle   (ctx, 0, 0, 80, 24);
  ctx_fill        (ctx);
  ctx_move_to     (ctx, 10, 9);
  ctx_font_size   (ctx, 12);
  ctx_line_width  (ctx, 2);
  ctx_rgba        (ctx, 0, 0, 0, 1);
  ctx_text_stroke (ctx, utf8);
  ctx_rgba        (ctx, 1,0, 1.0, 1.0, 1.0);
  ctx_move_to     (ctx, 10, 9);
  ctx_text        (ctx, utf8);
  ctx_free        (ctx);

  static char *utf8_gray_scale[]={" ","░","▒","▓","█","█", NULL};
  int no=0;
  for (int y= 0; y &lt; HEIGHT; y++)
  {
    for (int x = 0; x &lt; WIDTH; x++, no+=4)
      printf ("%s", utf8_gray_scale[5-(int)CTX_CLAMP(pixels[no+1]/255.0*6.0, 0, 5)]);
    printf ("\n");
  }

  return 0;
}
</pre>
which outputs (the rightmost column of pixels is a bug):
<pre>
~/src/ctx/tests$ ./test-size 
▓▓▓▓▓▓▓▓▓▓▓█▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓██▓▓█ █▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓██ ██████████▓██▓▓▓██▓▓██▓████▓▓█████▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓█░  ░█ ██░░ ░██ █▓█ █   ▓█▒  ███   ▓▓   █▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓██ ███ ██ ▓█░██░███░█▓▓██▓░██░██░████▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ █▓█ ██░██▓▓█▓▒█▒▓█▓▒██░▓██░▓█ ▓███▒██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ █▓█ ██░██▓▓██ █ ██▓▓██░▒▓▓▓███▒░▒█▒█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█ ███ ██░██▓▓██▒░▒██▓▓██▒▒████████░█▒███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓█▒░▒█ ██░██▓▓██▓ █▓██░░██░░▒░█▓░▒░▓██░░█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓█████▓██▓▓██▓██ █▓▓████▓██████████▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓ █▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█ █▓▓▓▓▓▓▓▓▓▓▓▓▓██░░█▓▓▓▓▓▓▓▓▓▓▓█▒▓█▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓████▓▓▓█████ ███▓▓▓████▓▓▓▓█░███████▓▓████▓█▒▓███▓▓████▓▓████
▓▓▓▓▓▓▓▓▓▓██▒▒▓███   ▓█ ▒ ░█▓█▒  ██▓▓█▒  ░█▓  ████  ▒██▒░  ███   ▓██   █
▓▓▓▓▓▓▓▓▓██░██▒██▒▓████ ▓█▒▓█▓▒██░█▓▓██░███░██░██░██▒▓█▒░██░█████░██████
▓▓▓▓▓▓▓▓▓█▓▒██▓▒█ █▓▓▓█ ███▒█░███░█▓▓▓█░██▓▓██▓▓█ ███░█▒▓██▒███▓▓░▓███░█
▓▓▓▓▓▓▓▓▓█▓▒█████ █▓▓▓█ ███▒█░█▓█░█▓▓▓█░██▒▓██▓▓█░███░█▒▓██▒▓█ ██▒▓██░▓█
▓▓▓▓▓▓▓▓▓█▓░█████░█████ ███▒█░▓██ █▓▓▓█░██▓░██░██ ██▓░█▒▒██░██░██░▓█▒▒██
▓▓▓▓▓▓▓▓▓▓█▓░▒░▓██ ▒░██ ███▒██░░ ▓█▓▓▓█░█▓█▒  ▒██▓ ░░██▒░▒░▒██░░░▒▓█ ▒▒█
▓▓▓▓▓▓▓▓▓▓▓█████▓███████▓▓██▓▓████▓▓▓▓▓██▓▓████▓▓████▓██████▓▓██████████
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█
</pre>

<p>To fetch, build, and run ctx, and an example similar to the above
run the following:

<pre>
mkdir foo;cd foo;wget http://ctx.graphics/{ctx.h,ctx-font-regular.h,hello.c};make hello &amp;&amp; ./hello</pre>
</p>

  -->
              </div>
      </body>
</html>
